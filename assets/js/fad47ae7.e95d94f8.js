"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[788],{1523:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var i=r(4848),t=r(8453);const s={id:"05-u-extending-tool",title:"Extending the tool",sidebar_label:"Extending the tool"},a=void 0,l={id:"05-u-extending-tool",title:"Extending the tool",description:"Want to enable a new metric or a language, need advanced post-analysis tool? Please, check the plugin development tutorial.",source:"@site/docs/05-u-extending-tool.md",sourceDirName:".",slug:"/05-u-extending-tool",permalink:"/metrixplusplus/docs/05-u-extending-tool",draft:!1,unlisted:!1,editUrl:"https://metrixplusplus.github.io/docs/05-u-extending-tool.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"05-u-extending-tool",title:"Extending the tool",sidebar_label:"Extending the tool"},sidebar:"someSidebar",previous:{title:"Workflow",permalink:"/metrixplusplus/docs/04-u-workflow"},next:{title:"Feeback and contribute",permalink:"/metrixplusplus/docs/06-u-feeback-contribute"}},o={},c=[{value:"Create plugin",id:"create-plugin",level:2},{value:"Metric plugin",id:"metric-plugin",level:2},{value:"Create placeholder for new plugin",id:"create-placeholder-for-new-plugin",level:3},{value:"Toogle option for the plugin",id:"toogle-option-for-the-plugin",level:3},{value:"Subscribe to notifications from parent plugins (or code parsers)",id:"subscribe-to-notifications-from-parent-plugins-or-code-parsers",level:3},{value:"Implement simple metric based on regular expression pattern",id:"implement-simple-metric-based-on-regular-expression-pattern",level:3},{value:"Extend regular expression incremental counting by smarter logic",id:"extend-regular-expression-incremental-counting-by-smarter-logic",level:3},{value:"Language specific regular expressions",id:"language-specific-regular-expressions",level:3},{value:"Store only non-zero metric values",id:"store-only-non-zero-metric-values",level:3},{value:"Additional per metric configuration options",id:"additional-per-metric-configuration-options",level:3},{value:"Summary",id:"summary",level:3},{value:"Analysis tool plugin",id:"analysis-tool-plugin",level:2},{value:"New Metrix++ command / action",id:"new-metrix-command--action",level:3},{value:"Access data file loader and its interfaces",id:"access-data-file-loader-and-its-interfaces",level:3},{value:"Identify added, modified files/regions and read metric data",id:"identify-added-modified-filesregions-and-read-metric-data",level:3},{value:"Summary",id:"summary-1",level:3},{value:"Language parser plugin",id:"language-parser-plugin",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Want to enable a new metric or a language, need advanced post-analysis tool? Please, check the plugin development tutorial."}),"\n",(0,i.jsx)(n.h2,{id:"create-plugin",children:"Create plugin"}),"\n",(0,i.jsx)(n.p,{children:"There are 3 types of plugins considered in this chapter:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Metric plugin"}),"\n",(0,i.jsx)(n.li,{children:"Language parser"}),"\n",(0,i.jsx)(n.li,{children:"Post-processing / Analysis tool"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Tutorial for metric plugin is generic at the beginning and large portion of this is applied to all other plugins. You need to know python and python regular expressions library to write Metrix++ extensions."}),"\n",(0,i.jsx)(n.h2,{id:"metric-plugin",children:"Metric plugin"}),"\n",(0,i.jsx)(n.p,{children:"The tutorial will explain how to create a plugin to count magic numbers in source code. It will be relatively simple at first and will be extended with additional configuration options and smarter counting logic."}),"\n",(0,i.jsx)(n.h3,{id:"create-placeholder-for-new-plugin",children:"Create placeholder for new plugin"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"All plugins are loaded by Metrix++ from standard places within the tool installation directory and from custom places specified in the METRIXPLUSPLUS_PATH environment variable. METRIXPLUSPLUS_PATH has got the same format as system PATH environment variable. So, the first step in plugin development is to set the METRIXPLUSPLUS_PATH to point out to the directory (or directories) where plugin is located."}),"\n",(0,i.jsx)(n.li,{children:"Create new python package 'myext', python lib 'magic.py' and 'magic.ini' file."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"+ working_directory (set in METRIXPLUSPLUS_PATH variable)\r\n\\--+ myext\r\n   \\--- __init__.py\r\n   \\--- magic.py\r\n   \\--- magic.ini\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["_",(0,i.jsx)(n.em,{children:"init_"}),".py is empty file to make myext considered by python as a package."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Edit magic.py to have the following content:"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:'import mpp.api\r\n \r\nclass Plugin(mpp.api.Plugin):\r\n    \r\n    def initialize(self):\r\n        print "Hello world"\n'})}),"\n",(0,i.jsx)(n.p,{children:'mpp.api package include Metrix++ API classes. mpp.api.Plugin is the base class, which can be loaded by Metrix++ engine and does nothing by default. In the code sample above it is extended to print "Hello world" on initialization.'}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsx)(n.li,{children:"Edit magic.ini to have the following content:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[Plugin]\r\nversion: 1.0\r\npackage: myext\r\nmodule:  magic\r\nclass:   Plugin\r\ndepends: None\r\nactions: collect\r\nenabled: True\n"})}),"\n",(0,i.jsx)(n.p,{children:"This file is a manifest for Metrix++ plugin loader. The fields in Plugin section are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"version"})," -\r\na string representing the version, step up it every time when behaviour of a plugin or backward compatibility in api or data scope is changed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"package"})," -\r\npython package name where to load from"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"module"})," -\r\npython module name (filename of *.py file) to load"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"class"})," -\r\nname of a plugin class to instanciate"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"depends"})," -\r\nlist of plugin names to load, if it this plugin is loaded"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"actions"})," -\r\nlist of Metrix++ actions affected by this plugin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"enabled"})," -\r\nTrue or False, working status of a plugin"]}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{start:"6",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to see how this new plugin works:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Hello world\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toogle-option-for-the-plugin",children:"Toogle option for the plugin"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"It is recommended to follow the convention for all plugins: 'run only if enabled'. So, let's extend the magic.py file to make it configurable."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:'import mpp.api\r\n \r\nclass Plugin(mpp.api.Plugin,\r\n             # make this instance configurable...\r\n             mpp.api.IConfigurable):\r\n    # ... and implement 2 interfaces\r\n    \r\n    def declare_configuration(self, parser):\r\n        parser.add_option("--myext.magic.numbers", "--mmn",\r\n            action="store_true", default=False,\r\n            help="Enables collection of magic numbers metric [default: %default]")\r\n        \r\n    def configure(self, options):\r\n        self.is_active_numbers = options.__dict__[\'myext.magic.numbers\']\r\n    \r\n    def initialize(self):\r\n        # use configuration option here\r\n        if self.is_active_numbers == True:\r\n            print "Hello world"\n'})}),"\n",(0,i.jsx)(n.p,{children:"parser argument is an instance of optparse.OptionParser class. It has got an extension to accept multiple options of the same argument. Check std.tools.limit to see how to declare multiopt options, if you need."}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to see how this works:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect --myext.magic.numbers\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Hello world\n"})}),"\n",(0,i.jsx)(n.h3,{id:"subscribe-to-notifications-from-parent-plugins-or-code-parsers",children:"Subscribe to notifications from parent plugins (or code parsers)"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Every plugin works in a callback functions called by parent plugins. Callback receives a reference to parent plugin, data object where to store metrics data, and a flag indicating if there are changes in file or parent's settings since the previous collection."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:'import mpp.api\r\n \r\nclass Plugin(mpp.api.Plugin,\r\n             mpp.api.IConfigurable,\r\n             # declare that it can subscribe on notifications\r\n             mpp.api.Child):\r\n    \r\n    def declare_configuration(self, parser):\r\n        parser.add_option("--myext.magic.numbers", "--mmn",\r\n            action="store_true", default=False,\r\n            help="Enables collection of magic numbers metric [default: %default]")\r\n    \r\n    def configure(self, options):\r\n        self.is_active_numbers = options.__dict__[\'myext.magic.numbers\']\r\n    \r\n    def initialize(self):\r\n        if self.is_active_numbers == True:\r\n            # subscribe to notifications from all code parsers\r\n            self.subscribe_by_parents_interface(mpp.api.ICode, \'callback\')\r\n \r\n    # parents (code parsers) will call the callback declared\r\n    def callback(self, parent, data, is_updated):\r\n        print parent.get_name(), data.get_path(), is_updated\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to see how this works. Try to do iterative scans (--db-file-prev option) to see how the state of arguments is changed"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect --myext.magic.numbers\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"std.code.cpp ./test.cpp True\n"})}),"\n",(0,i.jsx)(n.h3,{id:"implement-simple-metric-based-on-regular-expression-pattern",children:"Implement simple metric based on regular expression pattern"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Callback may execute counting, searcing and additional parsing and store results, using data argument. 'data' argument is an instance of mpp.api.FileData class. However, most metrics can be implemented simplier, if mpp.api.MetricPluginMixin routines are used. MetricPluginMixin implements declarative style for metrics based on searches by regular expression. It cares about initialisation of database fields and properties. It implements default callback which counts number of matches by regular expression for all active declared metrics. So, let's utilise that:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"import mpp.api\r\nimport re\r\n \r\nclass Plugin(mpp.api.Plugin,\r\n             mpp.api.IConfigurable,\r\n             mpp.api.Child,\r\n             # reuse by inheriting standard metric facilities\r\n             mpp.api.MetricPluginMixin):\r\n    \r\n    def declare_configuration(self, parser):\r\n        parser.add_option(\"--myext.magic.numbers\", \"--mmn\",\r\n            action=\"store_true\", default=False,\r\n            help=\"Enables collection of magic numbers metric [default: %default]\")\r\n    \r\n    def configure(self, options):\r\n        self.is_active_numbers = options.__dict__['myext.magic.numbers']\r\n    \r\n    def initialize(self):\r\n        # declare metric rules\r\n        self.declare_metric(\r\n            self.is_active_numbers, # to count if active in callback\r\n            self.Field('numbers', int), # field name and type in the database\r\n            re.compile(r'''\\b[0-9]+\\b'''), # pattern to search\r\n            marker_type_mask=mpp.api.Marker.T.CODE, # search in code\r\n            region_type_mask=mpp.api.Region.T.ANY) # search in all types of regions\r\n        \r\n        # use superclass facilities to initialize everything from declared fields\r\n        super(Plugin, self).initialize(fields=self.get_fields())\r\n        \r\n        # subscribe to all code parsers if at least one metric is active\r\n        if self.is_active() == True:\r\n            self.subscribe_by_parents_interface(mpp.api.ICode)\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to count numbers in code files."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect --myext.magic.numbers\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Now view the results. At this stage it is fully working simple metric."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" view\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:":: info: Overall metrics for 'myext.magic:numbers' metric\r\n\tAverage        : 2.75\r\n\tMinimum        : 0\r\n\tMaximum        : 7\r\n\tTotal          : 11.0\r\n\tDistribution   : 4 regions in total (including 0 suppressed)\r\n\t  Metric value : Ratio : R-sum : Number of regions\r\n\t             0 : 0.250 : 0.250 : 1\t|||||||||||||||||||||||||\r\n\t             1 : 0.250 : 0.500 : 1\t|||||||||||||||||||||||||\r\n\t             3 : 0.250 : 0.750 : 1\t|||||||||||||||||||||||||\r\n\t             7 : 0.250 : 1.000 : 1\t|||||||||||||||||||||||||\r\n\r\n:: info: Directory content:\r\n\tDirectory      : .\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extend-regular-expression-incremental-counting-by-smarter-logic",children:"Extend regular expression incremental counting by smarter logic"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"At this stage the metric counts every number in source code. However, we indent to spot only 'magic' numbers. Declared constant is not a magic number, so it is better to exclude constants from counting. It is easy to change default counter behaviour by implementing a function with name '_<metric_name>_count'."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"import mpp.api\r\nimport re\r\n \r\nclass Plugin(mpp.api.Plugin,\r\n             mpp.api.IConfigurable,\r\n             mpp.api.Child,\r\n             mpp.api.MetricPluginMixin):\r\n    \r\n    def declare_configuration(self, parser):\r\n        parser.add_option(\"--myext.magic.numbers\", \"--mmn\",\r\n            action=\"store_true\", default=False,\r\n            help=\"Enables collection of magic numbers metric [default: %default]\")\r\n    \r\n    def configure(self, options):\r\n        self.is_active_numbers = options.__dict__['myext.magic.numbers']\r\n    \r\n    def initialize(self):\r\n        # improve pattern to find declarations of constants\r\n        pattern_to_search = re.compile(\r\n            r'''((const(\\s+[_a-zA-Z][_a-zA-Z0-9]*)+\\s*[=]\\s*)[-+]?[0-9]+\\b)|(\\b[0-9]+\\b)''')\r\n        self.declare_metric(self.is_active_numbers,\r\n                            self.Field('numbers', int),\r\n                            # give a pair of pattern + custom counter logic class\r\n                            (pattern_to_search, self.NumbersCounter),\r\n                            marker_type_mask=mpp.api.Marker.T.CODE,\r\n                            region_type_mask=mpp.api.Region.T.ANY)\r\n        \r\n        super(Plugin, self).initialize(fields=self.get_fields())\r\n        \r\n        if self.is_active() == True:\r\n            self.subscribe_by_parents_interface(mpp.api.ICode)\r\n    \r\n    # implement custom counter behavior:\r\n    # increments counter by 1 only if single number spotted,\r\n    # but not declaration of a constant\r\n    class NumbersCounter(mpp.api.MetricPluginMixin.IterIncrementCounter):\r\n        def increment(self, match):\r\n            if match.group(0).startswith('const'):\r\n                return 0\r\n            return 1\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Initialy counter is initialized by zero, but it is possible to change it as well by implementing a function with name '_<metric_name>_count_initialize'."}),"\n",(0,i.jsx)(n.li,{children:"Plugin we are implementing does not require this.\r\nNow run Metrix++ to collect and view the results."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect --myext.magic.numbers\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" view\n'})}),"\n",(0,i.jsx)(n.h3,{id:"language-specific-regular-expressions",children:"Language specific regular expressions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"In the previous step we added matching of constants assuming that identifiers may have symbols '_', 'a-z', 'A-Z' and '0-9'. It is true for C++ but it is not complete for Java. Java identifier may have '$' symbol in the identifier. So, let's add language specific pattern in the declaration of the metric:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"import mpp.api\r\nimport re\r\n \r\nclass Plugin(mpp.api.Plugin,\r\n             mpp.api.IConfigurable,\r\n             mpp.api.Child,\r\n             mpp.api.MetricPluginMixin):\r\n    \r\n    def declare_configuration(self, parser):\r\n        parser.add_option(\"--myext.magic.numbers\", \"--mmn\",\r\n            action=\"store_true\", default=False,\r\n            help=\"Enables collection of magic numbers metric [default: %default]\")\r\n    \r\n    def configure(self, options):\r\n        self.is_active_numbers = options.__dict__['myext.magic.numbers']\r\n    \r\n    def initialize(self):\r\n        # specialized pattern for java\r\n        pattern_to_search_java = re.compile(\r\n            r'''((const(\\s+[_$a-zA-Z][_$a-zA-Z0-9]*)+\\s*[=]\\s*)[-+]?[0-9]+\\b)|(\\b[0-9]+\\b)''')\r\n        # pattern for C++ and C# languages\r\n        pattern_to_search_cpp_cs = re.compile(\r\n            r'''((const(\\s+[_a-zA-Z][_a-zA-Z0-9]*)+\\s*[=]\\s*)[-+]?[0-9]+\\b)|(\\b[0-9]+\\b)''')\r\n        # pattern for all other languages\r\n        pattern_to_search = re.compile(\r\n            r'''\\b[0-9]+\\b''')\r\n        self.declare_metric(self.is_active_numbers,\r\n                            self.Field('numbers', int),\r\n                            # dictionary of pairs instead of a single pair\r\n                            {\r\n                             'std.code.java': (pattern_to_search_java, self.NumbersCounter),\r\n                             'std.code.cpp': (pattern_to_search_cpp_cs, self.NumbersCounter),\r\n                             'std.code.cs': (pattern_to_search_cpp_cs, self.NumbersCounter),\r\n                             '*': pattern_to_search\r\n                            },\r\n                            marker_type_mask=mpp.api.Marker.T.CODE,\r\n                            region_type_mask=mpp.api.Region.T.ANY)\r\n        \r\n        super(Plugin, self).initialize(fields=self.get_fields())\r\n        \r\n        if self.is_active() == True:\r\n            self.subscribe_by_parents_interface(mpp.api.ICode)\r\n \r\n    class NumbersCounter(mpp.api.MetricPluginMixin.IterIncrementCounter):\r\n        def increment(self, match):\r\n            if match.group(0).startswith('const'):\r\n                return 0\r\n            return 1\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Keys in the dictionary of patterns are names of parent plugins (references to code parsers). The key '*' refers to any parser."}),"\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to collect and view the results."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect --myext.magic.numbers\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" view\n'})}),"\n",(0,i.jsx)(n.h3,{id:"store-only-non-zero-metric-values",children:"Store only non-zero metric values"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Most functions have the metric, which we are implemneting, equal to zero. However, we are interested in finding code blocks having this metric greater than zero. Zeros consumes the space in the data file. So, we can optimise the size of a data file, if we exclude zero metric values. Let's declare this behavior for the metric."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"import mpp.api\r\nimport re\r\n \r\nclass Plugin(mpp.api.Plugin,\r\n             mpp.api.IConfigurable,\r\n             mpp.api.Child,\r\n             mpp.api.MetricPluginMixin):\r\n    \r\n    def declare_configuration(self, parser):\r\n        parser.add_option(\"--myext.magic.numbers\", \"--mmn\",\r\n            action=\"store_true\", default=False,\r\n            help=\"Enables collection of magic numbers metric [default: %default]\")\r\n    \r\n    def configure(self, options):\r\n        self.is_active_numbers = options.__dict__['myext.magic.numbers']\r\n    \r\n    def initialize(self):\r\n        pattern_to_search_java = re.compile(\r\n            r'''((const(\\s+[_$a-zA-Z][_$a-zA-Z0-9]*)+\\s*[=]\\s*)[-+]?[0-9]+\\b)|(\\b[0-9]+\\b)''')\r\n        pattern_to_search_cpp_cs = re.compile(\r\n            r'''((const(\\s+[_a-zA-Z][_a-zA-Z0-9]*)+\\s*[=]\\s*)[-+]?[0-9]+\\b)|(\\b[0-9]+\\b)''')\r\n        pattern_to_search = re.compile(\r\n            r'''\\b[0-9]+\\b''')\r\n        self.declare_metric(self.is_active_numbers,\r\n                            self.Field('numbers', int,\r\n                                # optimize the size of datafile:\r\n                                # store only non-zero results\r\n                                non_zero=True),\r\n                            {\r\n                             'std.code.java': (pattern_to_search_java, self.NumbersCounter),\r\n                             'std.code.cpp': (pattern_to_search_cpp_cs, self.NumbersCounter),\r\n                             'std.code.cs': (pattern_to_search_cpp_cs, self.NumbersCounter),\r\n                             '*': pattern_to_search\r\n                            },\r\n                            marker_type_mask=mpp.api.Marker.T.CODE,\r\n                            region_type_mask=mpp.api.Region.T.ANY)\r\n        \r\n        super(Plugin, self).initialize(fields=self.get_fields())\r\n        \r\n        if self.is_active() == True:\r\n            self.subscribe_by_parents_interface(mpp.api.ICode)\r\n \r\n    class NumbersCounter(mpp.api.MetricPluginMixin.IterIncrementCounter):\r\n        def increment(self, match):\r\n            if match.group(0).startswith('const'):\r\n                return 0\r\n            return 1\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to collect and view the results."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect --myext.magic.numbers\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" view\n'})}),"\n",(0,i.jsx)(n.h3,{id:"additional-per-metric-configuration-options",children:"Additional per metric configuration options"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"It is typical that most numbers counted by the metric are equal to 0, -1 or 1. They are not necessary magic numbers. 0 or 1 are typical variable initializers. -1 is a typical negative return code. So, let's implement simplified version of the metric, which does not count 0, -1 and 1, if the specific new option is set."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"import mpp.api\r\nimport re\r\n \r\nclass Plugin(mpp.api.Plugin,\r\n             mpp.api.IConfigurable,\r\n             mpp.api.Child,\r\n             mpp.api.MetricPluginMixin):\r\n    \r\n    def declare_configuration(self, parser):\r\n        parser.add_option(\"--myext.magic.numbers\", \"--mmn\",\r\n            action=\"store_true\", default=False,\r\n            help=\"Enables collection of magic numbers metric [default: %default]\")\r\n        # Add new option\r\n        parser.add_option(\"--myext.magic.numbers.simplier\", \"--mmns\",\r\n            action=\"store_true\", default=False,\r\n            help=\"Is set, 0, -1 and 1 numbers are not counted [default: %default]\")\r\n    \r\n    def configure(self, options):\r\n        self.is_active_numbers = options.__dict__['myext.magic.numbers']\r\n        # remember the option here\r\n        self.is_active_numbers_simplier = options.__dict__['myext.magic.numbers.simplier']\r\n    \r\n    def initialize(self):\r\n        pattern_to_search_java = re.compile(\r\n            r'''((const(\\s+[_$a-zA-Z][_$a-zA-Z0-9]*)+\\s*[=]\\s*)[-+]?[0-9]+\\b)|(\\b[0-9]+\\b)''')\r\n        pattern_to_search_cpp_cs = re.compile(\r\n            r'''((const(\\s+[_a-zA-Z][_a-zA-Z0-9]*)+\\s*[=]\\s*)[-+]?[0-9]+\\b)|(\\b[0-9]+\\b)''')\r\n        pattern_to_search = re.compile(\r\n            r'''\\b[0-9]+\\b''')\r\n        self.declare_metric(self.is_active_numbers,\r\n                            self.Field('numbers', int,\r\n                                non_zero=True),\r\n                            {\r\n                             'std.code.java': (pattern_to_search_java, self.NumbersCounter),\r\n                             'std.code.cpp': (pattern_to_search_cpp_cs, self.NumbersCounter),\r\n                             'std.code.cs': (pattern_to_search_cpp_cs, self.NumbersCounter),\r\n                             '*': pattern_to_search\r\n                            },\r\n                            marker_type_mask=mpp.api.Marker.T.CODE,\r\n                            region_type_mask=mpp.api.Region.T.ANY)\r\n        \r\n        super(Plugin, self).initialize(fields=self.get_fields(),\r\n            # remember option settings in data file properties\r\n            # in order to detect changes in settings on iterative re-run\r\n            properties=[self.Property('number.simplier', self.is_active_numbers_simplier)])\r\n        \r\n        if self.is_active() == True:\r\n            self.subscribe_by_parents_interface(mpp.api.ICode)\r\n \r\n    class NumbersCounter(mpp.api.MetricPluginMixin.IterIncrementCounter):\r\n        def increment(self, match):\r\n            if (match.group(0).startswith('const') or\r\n                (self.plugin.is_active_numbers_simplier == True and\r\n                 match.group(0) in ['0', '1', '-1', '+1'])):\r\n                return 0\r\n            return 1\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to collect and view the results."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" collect --myext.magic.numbers\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" view\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:":: info: Overall metrics for 'myext.magic:numbers' metric\r\n\tAverage        : 2.5 (excluding zero metric values)\r\n\tMinimum        : 2\r\n\tMaximum        : 3\r\n\tTotal          : 5.0\r\n\tDistribution   : 2 regions in total (including 0 suppressed)\r\n\t  Metric value : Ratio : R-sum : Number of regions\r\n\t             2 : 0.500 : 0.500 : 1\t||||||||||||||||||||||||||||||||||||||||||||||||||\r\n\t             3 : 0.500 : 1.000 : 1\t||||||||||||||||||||||||||||||||||||||||||||||||||\r\n\r\n:: info: Directory content:\r\n\tDirectory      : .\n"})}),"\n",(0,i.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"We have finished with the tutorial. The tutorial explained how to implement simple and advanced metric plugins. We used built-in Metrix++ base classes. If you need to more advanced plugin capabilities, override in your plugin class functions inherited from mpp.api base classes. Check code of standard plugins to learn more techniques."}),"\n",(0,i.jsx)(n.h2,{id:"analysis-tool-plugin",children:"Analysis tool plugin"}),"\n",(0,i.jsx)(n.p,{children:"This tutorial will explain how to build custom Metrix++ command, which is bound to custom post-analysis tool. We will implement the tool, which identifies all new and changed regions and counts number of added lines. We skip calculating number of deleted lines, but it is easy to extend from what we get finally in the tutorial."}),"\n",(0,i.jsx)(n.h3,{id:"new-metrix-command--action",children:"New Metrix++ command / action"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"As in the tutorial for metric plugin, set the environment and create new python package 'myext', python lib 'compare.py' and 'compare.ini' file."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"+ working_directory (set in METRIXPLUSPLUS_PATH variable)\r\n\\--+ myext\r\n   \\--- __init__.py\r\n   \\--- compare.py\r\n   \\--- compare.ini\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"init"}),".py is empty file to make myext considered by python as a package."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Edit compare.py to have the following content:"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"import mpp.api\r\n \r\nclass Plugin(mpp.api.Plugin, mpp.api.IRunable):\r\n    \r\n    def run(self, args):\r\n        print args\r\n        return 0\n"})}),"\n",(0,i.jsx)(n.p,{children:"Inheritance from mpp.api.IRunable declares that the plugin is runable and requires implementation of 'run' interface."}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsx)(n.li,{children:"Edit compare.ini to have the following content:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[Plugin]\r\nversion: 1.0\r\npackage: myext\r\nmodule:  compare\r\nclass:   Plugin\r\ndepends: None\r\nactions: compare\r\nenabled: True\n"})}),"\n",(0,i.jsx)(n.p,{children:"This file is a manifest for Metrix++ plugin loader. Actions field has got new value 'compare'. Metrix++ engine will automatically pick this action and will add it to the list of available commands. This plugin will be loaded on 'compare' action."}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to see how this new plugin works:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" compare -- path1 path2 path3\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'["path1", "path2", "path3"]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"access-data-file-loader-and-its-interfaces",children:"Access data file loader and its interfaces"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["By default, all post-analysis tools have got --db-file and --db-file-prev options. It is because 'mpp.dbf' plugin is loaded for any action, including our new one 'compare'. In order to continue the tutorial, we need to have 2 data files with 'std.code.lines",":total","' metric collected. So, write to files by running:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> cd my_project_version_1\r\n> python "/path/to/metrix++.py" collect --std.code.lines.total\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> cd my_project_version_2\r\n> python "/path/to/metrix++.py" collect --std.code.lines.total\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Edit compare.py file to get the loader and iterate collected file paths:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"import mpp.api\r\n# load common utils for post processing tools\r\nimport mpp.utils\r\n \r\nclass Plugin(mpp.api.Plugin, mpp.api.IRunable):\r\n    \r\n    def run(self, args):\r\n        # get data file reader using standard metrix++ plugin\r\n        loader = self.get_plugin('mpp.dbf').get_loader()\r\n        \r\n        # iterate and print file length for every path in args\r\n        exit_code = 0\r\n        for path in (args if len(args) > 0 else [\"\"]):\r\n            file_iterator = loader.iterate_file_data(path)\r\n            if file_iterator == None:\r\n                mpp.utils.report_bad_path(path)\r\n                exit_code += 1\r\n                continue\r\n            for file_data in file_iterator:\r\n                print file_data.get_path()\r\n        return exit_code\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to see how it works:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" compare --db-file=my_project_version_2/metrixpp.db --db-file-prev=my_project_version_1/metrixpp.db\n'})}),"\n",(0,i.jsx)(n.h3,{id:"identify-added-modified-filesregions-and-read-metric-data",children:"Identify added, modified files/regions and read metric data"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Let's extend the logic of the tool to compare files and regions, read 'std.code.lines",":total","' metric and calcuate the summary of number of added lines. mpp.utils.FileRegionsMatcher is helper class which does matching and comparison of regions for 2 given mpp.api.FileData objects."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"import mpp.api\r\nimport mpp.utils\r\nimport mpp.cout\r\n \r\nclass Plugin(mpp.api.Plugin, mpp.api.IRunable):\r\n    \r\n    def run(self, args):\r\n        loader = self.get_plugin('mpp.dbf').get_loader()\r\n        # get previous db file loader\r\n        loader_prev = self.get_plugin('mpp.dbf').get_loader_prev()\r\n        \r\n        exit_code = 0\r\n        for path in (args if len(args) > 0 else [\"\"]):\r\n            added_lines = 0\r\n            file_iterator = loader.iterate_file_data(path)\r\n            if file_iterator == None:\r\n                mpp.utils.report_bad_path(path)\r\n                exit_code += 1\r\n                continue\r\n            for file_data in file_iterator:\r\n                added_lines += self._compare_file(file_data, loader, loader_prev)\r\n            mpp.cout.notify(path, '', mpp.cout.SEVERITY_INFO,\r\n                            \"Change trend report\",\r\n                            [('Added lines', added_lines)])\r\n        return exit_code\r\n \r\n    def _compare_file(self, file_data, loader, loader_prev):\r\n        # compare file with previous and return number of new lines\r\n        file_data_prev = loader_prev.load_file_data(file_data.get_path())\r\n        if file_data_prev == None:\r\n            return self._sum_file_regions_lines(file_data)\r\n        elif file_data.get_checksum() != file_data_prev.get_checksum():\r\n            return self._compare_file_regions(file_data, file_data_prev)\r\n \r\n    def _sum_file_regions_lines(self, file_data):\r\n        # just sum up the metric for all regions\r\n        result = 0\r\n        for region in file_data.iterate_regions():\r\n            result += region.get_data('std.code.lines', 'total')\r\n    \r\n    def _compare_file_regions(self, file_data, file_data_prev):\r\n        # compare every region with previous and return number of new lines\r\n        matcher = mpp.utils.FileRegionsMatcher(file_data, file_data_prev)\r\n        result = 0\r\n        for region in file_data.iterate_regions():\r\n            if matcher.is_matched(region.get_id()) == False:\r\n                # if added region, just add the lines\r\n                result += region.get_data('std.code.lines', 'total')\r\n            elif matcher.is_modified(region.get_id()):\r\n                # if modified, add the difference in lines\r\n                region_prev = file_data_prev.get_region(\r\n                    matcher.get_prev_id(region.get_id()))\r\n                result += (region.get_data('std.code.lines', 'total') -\r\n                           region_prev.get_data('std.code.lines', 'total'))\r\n        return result\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Now run Metrix++ to see how it works:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> python "/path/to/metrix++.py" compare --db-file=my_project_version_2/metrixpp.db --db-file-prev=my_project_version_1/metrixpp.db\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:":: info: Change trend report\r\n\tAdded lines    : 7\n"})}),"\n",(0,i.jsx)(n.h3,{id:"summary-1",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"We have finished with the tutorial. The tutorial explained how to read Metrix++ data files and implement custom post-processing tools. Even if some existing Metrix++ code requires clean-up and refactoring, check code of standard tool plugins to learn more techniques."}),"\n",(0,i.jsx)(n.h2,{id:"language-parser-plugin",children:"Language parser plugin"}),"\n",(0,i.jsx)(n.p,{children:"Unfortunately, there is no good documentation at this stage for this part. Briefly, if metric plugin counts and stores data into FileData object, tool plugin reads this data, language plugin construct the original structure of FileData object. The orginal structure includes regions (like functions, classes, etc.) and markers (like comments, strings, preprocessor, etc.). Check code of existing parsers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a language parser plugin is registered in the same way as a metric plugin"}),"\n",(0,i.jsx)(n.li,{children:"it registers parser's callback in 'std.tools.collect' plugin"}),"\n",(0,i.jsx)(n.li,{children:"parses a file in a callback, called by 'std.tools.collect'"}),"\n",(0,i.jsx)(n.li,{children:"parser needs to identify markers and regions and tell about this to file data object passed as an argument for the callback."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There are useful options and tools avaialble for trobuleshooting purposes during development:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"metrix++.py debug generates html code showing parsed code structures and their boundaries"}),"\n",(0,i.jsx)(n.li,{children:"--nest-regions for view tool forces the viewer to indent subregions."}),"\n",(0,i.jsx)(n.li,{children:"--log-level option is available for any command and is helpful to trace execution."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, if there are any questions or enquires, please, feel free to ",(0,i.jsx)(n.a,{href:"https://github.com/metrixplusplus/metrixplusplus/issues/new",children:"submit new question"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);